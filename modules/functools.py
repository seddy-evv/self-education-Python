# The functools module in Python provides higher-order functions and tools to aid in functional programming.
# These tools are primarily used for working with functions and callable objects, enabling tasks like partial
# function application, caching, custom comparisons, and more.

# 1. functools.lru_cache
# Description: Provides a decorator to cache (or remember) the results of expensive function calls,
# improving performance for repeated calls with the same arguments. It uses a Least Recently Used (LRU) cache strategy
# to limit memory usage.
# Syntax: @lru_cache(maxsize=128, typed=False)
# maxsize: Maximum number of cache entries (default: 128). Set to None for unlimited cache.
# typed: If True, arguments of different types are cached separately (e.g., 1 and 1.0 are considered different).

# Example:
from functools import lru_cache

@lru_cache(maxsize=3)
def expensive_function(n):
    print(f"Computing {n}...")
    return n * n

print(expensive_function(2))  # Output: Computing 2... 4
print(expensive_function(2))  # Output: (cached) 4
print(expensive_function(3))  # Output: Computing 3... 9
print(expensive_function.cache_info())  # Cache statistics


# 2. functools.partial
# Description: Creates a new function where some arguments or keyword arguments of the original function are pre-filled.
# This is useful when you want to specialize a function with fixed parameters.
# Syntax: functools.partial(func, *args, **keywords)

# Example:
from functools import partial

def multiply(x, y):
    return x * y

# Create a partial function with x fixed to 10
multiply_by_10 = partial(multiply, 10)

print(multiply_by_10(5))  # Output: 50
print(multiply(10, 5))    # Output: 50


# 3. functools.reduce
# Description: Applies a binary function (a function that takes two arguments) cumulatively to the items in a sequence,
# reducing the sequence to a single value. It's useful for tasks like summation, product calculation, or other reductions.
# Syntax: functools.reduce(function, iterable[, initializer])

# Example:
from functools import reduce

# Example: Compute the product of a list
numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 120


# 4. functools.wraps
# Description: A decorator for creating well-behaved decorators. It ensures that the metadata
# (like the __name__ and __doc__ attributes) of the original function is preserved when wrapped by a decorator.

# Example:

from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Before calling the function...")
        result = func(*args, **kwargs)
        print("After calling the function...")
        return result
    return wrapper

@my_decorator
def greet():
    """This is a greeting function."""
    print("Hello, world!")

greet()
print(greet.__name__)   # Output: greet (preserved by @wraps)
print(greet.__doc__)    # Output: This is a greeting function.


# 5. functools.cached_property (Python 3.8+)
# Description: Acts like a property decorator but caches the computed result. The value is only computed once and stored,
# avoiding recomputation unless the instance is deleted.
# Syntax: @cached_property

# Example:
from functools import cached_property

class Circle:
    def __init__(self, radius):
        self.radius = radius

    @cached_property
    def area(self):
        print("Calculating area...")
        return 3.14159 * self.radius ** 2

c = Circle(10)
print(c.area)  # Output: Calculating area... 314.159
print(c.area)  # Output: 314.159 (cached, no re-computation)


# **6. functools.total_ordering
# Description: A class decorator that makes it easier to implement all the rich comparison methods (<, <=, >, >=, ==, !=).
# If you define __eq__ and one other comparison method (like __lt__), it will automatically generate the rest.

# Example:
from functools import total_ordering

@total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age

    def __lt__(self, other):
        return self.age < other.age

p1 = Person("Alice", 30)
p2 = Person("Bob", 25)

print(p1 > p2)  # Output: True (based on age)
print(p1 >= p2) # Output: True (auto-generated by @total_ordering)


# **7. functools.singledispatch
# Description: Provides a way to define a single-dispatch generic function, which allows you to write different
# implementations of a function based on the type of the first argument. It acts as a basic form of function overloading
# for Python.
# Syntax: @singledispatch

# Example:
from functools import singledispatch

@singledispatch
def process(arg):
    print(f"Default: {arg}")

@process.register(int)
def _(arg):
    print(f"Integer: {arg * 2}")

@process.register(str)
def _(arg):
    print(f"String: {arg.upper()}")

process(10)        # Output: Integer: 20
process("hello")   # Output: String: HELLO
process([1, 2, 3]) # Output: Default: [1, 2, 3]


# 8. functools.singledispatchmethod (Python 3.8+)
# Description: Similar to singledispatch, but for methods within a class. Allows you to overload methods within a single
# class depending on the type of the first argument.
# Syntax: @singledispatchmethod

# Example:
from functools import singledispatchmethod

class Processor:
    @singledispatchmethod
    def process(self, arg):
        print(f"Default: {arg}")

    @process.register(int)
    def _(self, arg):
        print(f"Integer: {arg * 2}")

    @process.register(str)
    def _(self, arg):
        print(f"String: {arg.upper()}")


p = Processor()
p.process(10)        # Output: Integer: 20
p.process("hello")   # Output: String: HELLO
p.process([1, 2, 3]) # Output: Default: [1, 2, 3]


# 9. functools.cmp_to_key
# Converts an old-style comparison function (cmp) into a key function that can be used by functions like sorted() or min().

from functools import cmp_to_key

def compare(x, y):
    return (x > y) - (x < y)


values = [5, 2, 9, 1, 3]
sorted_values = sorted(values, key=cmp_to_key(compare))
print(sorted_values)  # Output: [1, 2, 3, 5, 9]

# Function	            Use Case
# lru_cache	            Cache function results for improved performance.
# partial	            Create a new function with pre-filled arguments.
# reduce	            Apply a function cumulatively to reduce an iterable to a single value.
# wraps	                Preserve the metadata of the original function when writing decorators.
# cached_property	    Cache a property's computed result for faster subsequent access.
# total_ordering	    Simplify implementation of all comparison methods.
# singledispatch	    Implement type-based function overloading.
# singledispatchmethod	Implement type-based method overloading in classes.
# cmp_to_key	        Convert old-style comparison functions into key functions for sorting.
